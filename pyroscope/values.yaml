# Default values for pyroscope.

global:
  # -- Overrides the Docker registry globally for all images
  registry: null
  # -- Overrides the priorityClassName for all pods
  priorityClassName: null
  # -- configures cluster domain ("cluster.local" by default)
  clusterDomain: "cluster.local"
  # -- configures DNS service name
  dnsService: "kube-dns"
  # -- configures DNS service namespace
  dnsNamespace: "kube-system"

pyroscope:
  # Global replica count (used when components are not specified)
  replicaCount: 2

  # -- Kubernetes cluster domain suffix for DNS discovery
  cluster_domain: .cluster.local.

  image:
    repository: grafana/pyroscope
    pullPolicy: IfNotPresent
    # Allows to override the image tag, which defaults to the appVersion in the chart metadata
    tag: ""

  extraArgs:
    log.level: info
    config.expand-env: true
    # Microservices mode specific args
    store-gateway.sharding-ring.replication-factor: "3"

  extraLabels: {}

  extraEnvVars:
    []
  
  # -- Environment variables from secrets or configmaps to add to the pods
  extraEnvFrom:
    - secretRef:
        name: pyroscope-secret

  imagePullSecrets: []
  dnsPolicy: ClusterFirst
  initContainers: []
  nameOverride: ""
  fullnameOverride: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations:
    # Scrapes itself see https://grafana.com/docs/pyroscope/latest/deploy-kubernetes/helm/#optional-scrape-your-own-workloads-profiles
    profiles.grafana.com/memory.scrape: "true"
    profiles.grafana.com/memory.port_name: http2
    profiles.grafana.com/cpu.scrape: "true"
    profiles.grafana.com/cpu.port_name: http2
    profiles.grafana.com/goroutine.scrape: "true"
    profiles.grafana.com/goroutine.port_name: http2
    # profiles.grafana.com/block.scrape: "true"
    # profiles.grafana.com/mutex.scrape: "true"

  podSecurityContext:
    fsGroup: 10001
    runAsUser: 10001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  podDisruptionBudget:
    enabled: true
    maxUnavailable: 1

  securityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
    runAsNonRoot: true
    runAsUser: 10001

  service:
    type: ClusterIP
    port: 4040
    port_name: http2
    scheme: HTTP
    annotations: {}

  memberlist:
    port: 7946
    port_name: memberlist

  # Global resource settings (can be overridden per component)
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
    limits:
      memory: 512Mi

  nodeSelector: {}

  # -- Topology Spread Constraints
  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: topology.kubernetes.io/zone
      whenUnsatisfiable: ScheduleAnyway
      labelSelector:
        matchLabels:
          app.kubernetes.io/name: pyroscope

  # Gateway configuration for authentication
  gateway:
    # -- Specifies whether the gateway should be enabled
    enabled: true
    # -- Number of replicas for the gateway
    replicas: 1
    # -- Default container port
    containerPort: 8080
    # -- Enable logging of 2xx and 3xx HTTP requests
    verboseLogging: true
    autoscaling:
      # -- Enable autoscaling for the gateway
      enabled: false
      # -- Minimum autoscaling replicas for the gateway
      minReplicas: 1
      # -- Maximum autoscaling replicas for the gateway
      maxReplicas: 3
      # -- Target CPU utilisation percentage for the gateway
      targetCPUUtilizationPercentage: 60
      # -- Target memory utilisation percentage for the gateway
      targetMemoryUtilizationPercentage:
    deploymentStrategy:
      type: RollingUpdate
    image:
      # -- The Docker registry for the gateway image
      registry: docker.io
      # -- The gateway image repository
      repository: nginxinc/nginx-unprivileged
      # -- The gateway image tag
      tag: 1.27-alpine
      # -- Overrides the gateway image tag with an image digest
      digest: null
      # -- The gateway image pull policy
      pullPolicy: IfNotPresent
    # -- The name of the PriorityClass for gateway pods
    priorityClassName: null
    # -- Annotations for gateway deployment
    annotations: {}
    # -- Annotations for gateway pods
    podAnnotations: {}
    # -- Additional labels for gateway pods
    podLabels: {}
    # -- Additional CLI args for the gateway
    extraArgs:
      - -config.expand-env=true
    # -- Environment variables to add to the gateway pods
    extraEnv: []
    # -- Environment variables from secrets or configmaps to add to the gateway pods
    extraEnvFrom:
      - secretRef:
          name: pyroscope-secret
    # -- Lifecycle for the gateway container
    lifecycle: {}
    # -- Volumes to add to the gateway pods
    extraVolumes: []
    # -- Volume mounts to add to the gateway pods
    extraVolumeMounts: []
    # -- The SecurityContext for gateway containers
    podSecurityContext:
      fsGroup: 101
      runAsGroup: 101
      runAsNonRoot: true
      runAsUser: 101
    # -- The SecurityContext for gateway containers
    containerSecurityContext:
      readOnlyRootFilesystem: true
      capabilities:
        drop:
          - ALL
      allowPrivilegeEscalation: false
    # -- Resource requests and limits for the gateway
    resources: {}
    # -- Containers to add to the gateway pods
    extraContainers: []
    # -- Grace period to allow the gateway to shutdown before it is killed
    terminationGracePeriodSeconds: 30
    # -- Affinity for gateway pods.
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                app.kubernetes.io/component: gateway
            topologyKey: kubernetes.io/hostname
    # -- DNS config for gateway pods
    dnsConfig: {}
    # -- Node selector for gateway pods
    nodeSelector: {}
    # -- Topology Spread Constraints for gateway pods
    topologySpreadConstraints: []
    # -- Tolerations for gateway pods
    tolerations: []
    # Gateway service configuration
    service:
      # -- Port of the gateway service
      port: 80
      # -- Type of the gateway service
      type: ClusterIP
      # -- ClusterIP of the gateway service
      clusterIP: null
      # -- (int) Node port if service type is NodePort
      nodePort: null
      # -- Load balancer IPO address if service type is LoadBalancer
      loadBalancerIP: null
      # -- Annotations for the gateway service
      annotations:
        konghq.com/read-timeout: "600000"
        konghq.com/connect-timeout: "600000"
        nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
        nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
        nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
      # -- Labels for gateway service
      labels: {}
    # Basic auth configuration
    basicAuth:
      # -- Enables basic authentication for the gateway
      enabled: true
      # -- The basic auth username for the gateway
      username: null
      # -- The basic auth password for the gateway
      password: null
      # -- Uses the specified users to create the htpasswd file
      htpasswd: >-
        {{ if .Values.pyroscope.gateway.basicAuth.username }}
        {{ htpasswd (required "'gateway.basicAuth.username' is required" .Values.pyroscope.gateway.basicAuth.username) (required "'gateway.basicAuth.password' is required" .Values.pyroscope.gateway.basicAuth.password) }}
        {{ end }}
      # -- Existing basic auth secret to use. Must contain '.htpasswd'
      existingSecret: pyroscope-secret
    # Configures the readiness probe for the gateway
    readinessProbe:
      httpGet:
        path: /
        port: http-metrics
      initialDelaySeconds: 15
      timeoutSeconds: 1
    nginxConfig:
      # -- Which schema to be used when building URLs. Can be 'http' or 'https'.
      schema: http
      # -- Enable listener for IPv6, disable on IPv4-only systems
      enableIPv6: true
      # -- NGINX log format
      logFormat: |-
        main '$remote_addr - $remote_user [$time_local]  $status '
                '"$request" $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for"';
      # -- Allows appending custom configuration to the server block
      serverSnippet: ""
      # -- Allows appending custom configuration to the http block
      httpSnippet: ""
      # -- Whether ssl should be appended to the listen directive of the server block or not.
      ssl: false
      # -- Override Read URL
      customReadUrl: null
      # -- Override Write URL
      customWriteUrl: null
      # -- Allows overriding the DNS resolver address nginx will use.
      resolver: ""
      # -- Config file contents for Nginx. Passed through the `tpl` function to allow templating
      file: |
        worker_processes  5;  ## Default: 1
        error_log  /dev/stderr;
        pid        /tmp/nginx.pid;
        worker_rlimit_nofile 8192;

        events {
          worker_connections  4096;  ## Default: 1024
        }

        http {
          client_body_temp_path /tmp/client_temp;
          proxy_temp_path       /tmp/proxy_temp_path;
          fastcgi_temp_path     /tmp/fastcgi_temp;
          uwsgi_temp_path       /tmp/uwsgi_temp;
          scgi_temp_path        /tmp/scgi_temp;

          proxy_http_version    1.1;

          default_type application/octet-stream;
          log_format   {{ .Values.pyroscope.gateway.nginxConfig.logFormat }}

          {{- if .Values.pyroscope.gateway.basicAuth.enabled }}
          map $status $loggable {
            ~^[23]  {{ .Values.pyroscope.gateway.verboseLogging }};
            default 1;
          }
          {{- end }}

          access_log   /dev/stderr  main {{ if .Values.pyroscope.gateway.basicAuth.enabled }}if=$loggable{{ end }};

          sendfile     on;
          tcp_nopush   on;
          {{- if .Values.pyroscope.gateway.nginxConfig.resolver }}
          resolver {{ .Values.pyroscope.gateway.nginxConfig.resolver }};
          {{- else }}
          resolver {{ .Values.global.dnsService }}.{{ .Values.global.dnsNamespace }}.svc.{{ .Values.global.clusterDomain }};
          {{- end }}

          {{- with .Values.pyroscope.gateway.nginxConfig.httpSnippet }}
          {{ . | nindent 2 }}
          {{- end }}

          server {
            listen             8080;
            {{- if .Values.pyroscope.gateway.nginxConfig.enableIPv6 }}
            listen             [::]:8080;
            {{- end }}

            location = / {
              return 200 'OK';
              auth_basic off;
              access_log off;
            }

            proxy_set_header X-Scope-OrgID $remote_user;

            # Pyroscope endpoints
            location / {
              {{- if .Values.pyroscope.gateway.basicAuth.enabled }}
              auth_basic           "Pyroscope";
              auth_basic_user_file /etc/nginx/secrets/.htpasswd;
              {{- end }}

              proxy_pass       http://{{ include "pyroscope.fullname" . }}.{{ .Release.Namespace }}.svc.{{ .Values.global.clusterDomain }}:{{ .Values.pyroscope.service.port }};
              proxy_http_version 1.1;
            }
          }
        }

  ## ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
  ## If you set enabled as "True", you need :
  ## - create a pv which above 10Gi and has same namespace with pyroscope
  ## - keep storageClassName same with below setting
  ## Global storage disabled - only enabled per component where needed
  persistence:
    enabled: false # Disabled globally - enabled per component as needed
    accessModes:
      - ReadWriteOnce
    size: 10Gi # Default size (overridden per component)
    storageClass: default
    annotations: {}
    # selector:
    #   matchLabels:
    #     app.kubernetes.io/name: pyroscope
    # subPath: ""
    # existingClaim:

  extraVolumes:
    []
    # - name: backup-volume
    #   emptydir: {}

  extraVolumeMounts:
    []
    # - name: testing
    #   mountPath: /var/lib/testing
    #   readOnly: false
    # - name: test-volume
    #   mountPath: /var/tmp/test-volume
    #   existingClaim: test-volume
    #   readOnly: false

  tolerations: []

  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchLabels:
                app.kubernetes.io/name: pyroscope
            topologyKey: kubernetes.io/hostname

  # Microservices mode - run specific components separately
  components:
    querier:
      kind: Deployment
      replicaCount: 3
      autoscaling:
        enabled: true
        minReplicas: 2
        maxReplicas: 6
        targetMemoryUtilizationPercentage: 60
        targetCPUUtilizationPercentage: null
        behavior:
          enabled: true
          scaleDown:
            stabilizationWindowSeconds: 60
      persistence:
        enabled: false # Stateless component - no persistence needed
      # resources:
      #   limits:
      #     memory: 1Gi
      #   requests:
      #     memory: 256Mi
      #     cpu: 1
    query-frontend:
      kind: Deployment
      replicaCount: 2
      autoscaling:
        enabled: true
        minReplicas: 2
        maxReplicas: 4
        targetMemoryUtilizationPercentage: 60
        targetCPUUtilizationPercentage: null
      persistence:
        enabled: false # Stateless component - no persistence needed
      # resources:
      #   limits:
      #     memory: 1Gi
      #   requests:
      #     memory: 256Mi
      #     cpu: 100m
    query-scheduler:
      kind: Deployment
      replicaCount: 2
      autoscaling:
        enabled: true
        minReplicas: 2
        maxReplicas: 4
        targetCPUUtilizationPercentage: 40
        targetMemoryUtilizationPercentage: null
      persistence:
        enabled: false # Stateless component - no persistence needed
      # resources:
      #   limits:
      #     memory: 1Gi
      #   requests:
      #     memory: 256Mi
      #     cpu: 100m
    distributor:
      kind: Deployment
      replicaCount: 2
      autoscaling:
        enabled: true
        minReplicas: 2
        maxReplicas: 5
        targetMemoryUtilizationPercentage: 60
        targetCPUUtilizationPercentage: null
      persistence:
        enabled: false # Stateless component - no persistence needed
      # resources:
      #   limits:
      #     memory: 1Gi
      #   requests:
      #     memory: 256Mi
      #     cpu: 500m
    ingester:
      kind: StatefulSet
      replicaCount: 3
      terminationGracePeriodSeconds: 600
      persistence:
        enabled: true # Critical: WAL for data safety and block storage
        size: 20Gi # Adequate space for WAL and temporary block storage
    compactor:
      kind: StatefulSet
      replicaCount: 3
      terminationGracePeriodSeconds: 1200
      persistence:
        enabled: true # Enable persistence for compactor - needs temp space for index processing
        size: 10Gi # Temporary storage for index file processing
      # resources:
      #   limits:
      #     memory: 16Gi
      #   requests:
      #     memory: 8Gi
      #     cpu: 1
    store-gateway:
      kind: StatefulSet
      replicaCount: 3
      persistence:
        # Enable persistence for store-gateway to cache index-headers and improve query performance
        # This avoids re-downloading index-headers on restart, reducing startup time
        enabled: true
        size: 5Gi # Storage for index-header cache
      # resources:
      #   limits:
      #     memory: 16Gi
      #   requests:
      #     memory: 8Gi
      #     cpu: 1
      readinessProbe:
        # The store gateway can be configured to wait on startup for ring stability to be reached before it becomes
        # ready. See the `store-gateway.sharding-ring.wait-stability-min-duration` server argument for more information.
        #
        # Depending on this flag and the number of tenants + blocks that need to be synced on startup, pods can take
        # some time to become ready. This value can be used to ensure Kubernetes waits long enough and reduce errors.
        initialDelaySeconds: 60
    tenant-settings:
      kind: Deployment
      replicaCount: 1 # Disabled - not needed for single-tenant setup
      autoscaling:
        enabled: false # Disable autoscaling when replicaCount is 0
        minReplicas: 1
        maxReplicas: 2
        targetMemoryUtilizationPercentage: 70
        targetCPUUtilizationPercentage: null
      persistence:
        enabled: false # Disabled component - no persistence needed
      # resources:
      #   limits:
      #     memory: 4Gi
      #   requests:
      #     memory: 16Mi
      #     cpu: 0.1
    ad-hoc-profiles:
      kind: Deployment
      replicaCount: 0 # Disabled - not needed for continuous profiling setup
      autoscaling:
        enabled: false # Disable autoscaling when replicaCount is 0
        minReplicas: 1
        maxReplicas: 2
        targetMemoryUtilizationPercentage: 70
        targetCPUUtilizationPercentage: null
      persistence:
        enabled: false # Disabled component - no persistence needed
      # resources:
      #   limits:
      #     memory: 4Gi
      #   requests:
      #     memory: 16Mi
      #     cpu: 0.1

  # -- Allows to override Pyroscope's configuration using structured format.
  structuredConfig: {}

  # -- Contains Pyroscope's configuration as a string.
  # @default -- The config depends on other values been set, details can be found in [`values.yaml`](./values.yaml)
  config: |
    storage:
      backend: azure
      azure:
        account_name: $${AZURE_ACCOUNT_NAME}
        account_key: $${AZURE_ACCOUNT_KEY}
        container_name: $${AZURE_CONTAINER_NAME}
        endpoint_suffix: "blob.core.windows.net"
    memberlist:
      join_members:
        - pyroscope-memberlist:7946
    server:
      http_listen_port: 4040
      log_level: info

    # Compactor configuration for data retention
    compactor:
      deletion_delay: 168h # 1 week
      compaction_interval: 2h

    # Global limits configuration  
    limits:
      ingestion_rate_mb: 50
      ingestion_burst_size_mb: 100
      max_query_lookback: 672h # 1 month
      max_query_parallelism: 32
      max_query_length: 672h # 1 month

  # -- Allows to add tenant specific overrides to the default limit configuration.
  tenantOverrides:
    {}
    # Use this section only if you need different limits for specific tenants
    # Example:
    # "tenant-heavy-usage":
    #   ingestion_rate_mb: 100
    #   ingestion_burst_size_mb: 200
  # -- Grafana Agent Configuration.

# -------------------------------------
# Configuration for `alloy` child chart
# -------------------------------------
alloy:
  enabled: false
  controller:
    type: "statefulset"
    replicas: 1
    podAnnotations:
      profiles.grafana.com/memory.scrape: "true"
      profiles.grafana.com/memory.port_name: "http-metrics"
      profiles.grafana.com/cpu.scrape: "true"
      profiles.grafana.com/cpu.port_name: "http-metrics"
      profiles.grafana.com/goroutine.scrape: "true"
      profiles.grafana.com/goroutine.port_name: "http-metrics"
      profiles.grafana.com/service_repository: "https://github.com/grafana/alloy"
      profiles.grafana.com/service_git_ref: "v1.8.1"

  alloy:
    stabilityLevel: "public-preview" # This needs to be set for some of our resources until verison v1.2 is released
    configMap:
      create: false
      name: alloy-config-pyroscope
    clustering:
      enabled: true

# -------------------------------------
# Configuration for `grafana-agent` child chart
# -------------------------------------
agent:
  enabled: false
  controller:
    type: "statefulset"
    replicas: 1
    podAnnotations:
      profiles.grafana.com/memory.scrape: "true"
      profiles.grafana.com/memory.port_name: "http-metrics"
      profiles.grafana.com/cpu.scrape: "true"
      profiles.grafana.com/cpu.port_name: "http-metrics"
      profiles.grafana.com/goroutine.scrape: "true"
      profiles.grafana.com/goroutine.port_name: "http-metrics"
  agent:
    configMap:
      create: false
      name: grafana-agent-config-pyroscope
    clustering:
      enabled: true

# -------------------------------------
# Configuration for `minio` child chart
# -------------------------------------
minio:
  enabled: false # Disabled because we're using Azure storage
  replicas: 1
  # Minio requires 2 to 16 drives for erasure code (drivesPerNode * replicas)
  # https://docs.min.io/docs/minio-erasure-code-quickstart-guide
  # Since we only have 1 replica, that means 2 drives must be used.
  drivesPerNode: 2
  rootUser: grafana-pyroscope
  rootPassword: supersecret
  buckets:
    - name: grafana-pyroscope-data
      policy: none
      purge: false
  persistence:
    size: 1Gi
  # resources:
  #   requests:
  #     cpu: 100m
  #     memory: 128Mi
  podAnnotations: {}

ingress:
  enabled: true
  className: "kong"
  annotations:
    konghq.com/https-redirect-status-code: "301"
    konghq.com/protocols: https
  hosts:
    - pyroscope-${env_type}-${region}.sitecorecloud.app
    - pyroscope-${env_type}-${region}.sitecorecloud.io
  tls: []

# ServiceMonitor configuration
serviceMonitor:
  # -- If enabled, ServiceMonitor resources for Prometheus Operator are created
  enabled: true
  # -- Namespace selector for ServiceMonitor resources
  namespaceSelector: {}
  # -- Optional expressions to match on
  matchExpressions:
    []
    # - key: prometheus.io/service-monitor
    #   operator: NotIn
    #   values:
    #     - "false"
  # -- ServiceMonitor annotations
  annotations: {}
  # -- Additional ServiceMonitor labels
  labels:
    release: kube-prometheus-stack
  # -- ServiceMonitor scrape interval
  interval: 30s
  # -- ServiceMonitor scrape timeout in Go duration format (e.g. 15s)
  scrapeTimeout: null
  # -- ServiceMonitor relabel configs to apply to samples before scraping
  # https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/api.md#relabelconfig
  relabelings: []
  # -- ServiceMonitor metric relabel configs to apply to samples before ingestion
  # https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#endpoint
  metricRelabelings: []
  # --ServiceMonitor will add labels from the service to the Prometheus metric
  # https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#servicemonitorspec
  targetLabels: []
  # -- ServiceMonitor will use http by default, but you can pick https as well
  scheme: http
  # -- ServiceMonitor will use these tlsConfig settings to make the health check requests
  tlsConfig: null
